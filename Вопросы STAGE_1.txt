Процедурное програмирование (функциональный подход) - приложение в ФП проходит через 3 основных этапа
1)Получение аргументов для работы
2)Выполнение функции
3)Возвращение результата
 
Основы ООП(Объектно-ориентированное програмирование) -его идея в том,что любую структуру в приложении можно представить в 
виде объекта или класса, со своими свойствами или методами.
Концепции(базовые):
1)Объект - элементарная еденица в ООП, которая представляет из себя набор свойств и каждое свойство состоит из имени
и значения или методов(посути функций) -это действий, которые может осуществлять объект.
2)Класс - рассширяемый шаблон кода, для создания объекта, который устанавливает в них начальные значения
и реализацию поведения.Может содержать конструктор - особый метод, который вызывается в момент инициализации класса и
создает свойства.
Концепции(основные):
1)Наследование - это создание новых классов на основе существующих.
2)Инкапсуляция- представляет собой сокрытие состояния объекта от прямого доступа из вне.(например использование геттеров/сеттеров
или public/private из TS)
3)Полиморфизм - это способность вызывать один и тот же метод для разных объектов и каждый объект на это действие реагировать по разному.(пример: класс -машина, каждый экземпляр будет выводить конкретную машину, хотя метод у всех один -просто вызов машины const car =new Cars("BMW"))
4)Интерфейс(является надстройкой над объектом/классом) - определяет свойсва или методы ,которые объект или класс должен реализовать, однако внутри себя не содержит ни каких реализаций.Важно помнить, что он не может создавать экземпляры класса, но на основе его создаются классы(через ключевое слово implements TS)
5)Абстракция -это способ создания простой модели, которая содержит только важные свойства с точки зрения контекста приложения из более сложной модели(abstract TS). (пример:Мы можем его описать как интерфейс, но методы можем не просто заявить , но и реализовать, почти как в обычном классе)
6)Композиция - это такой подход, при котором одни классы или объекты, содержат в себе другие, которые не могут существовать вне корневого класса(пример: в конструкторе- this.engine= new Engine())
7)Агрегация - идея в том, что классы которые используются внутри,остаются независимыми, передаю снаружи через параметры конструктора (как несте, constructor(item) this.engine=engine const car = new Cars(new Engine())) 

Базовые структуры данных
В программировании Big-О показывает, за сколько шагов (тактов процессора) выполняется алгоритм.
1)Массив
Упорядоченный набор элементов, к каждому из которых можно обратиться по его индексу (порядковому номеру в массиве).
Оптимален для индексирования (получения элемента массива через его номер).
Плох для поиска, вставки и удаления, если не делать этого в самом конце массива.
Вставка: недопустимо (если не делать этого в самом конце массива).

2)Список (связный список)
Данные хранятся в узлах, указывающих на другие узлы. По итогу список выглядит, как вложенные друг в друга объекты.
У каждого узла есть value (значение этого элемента(узла)) и nextNode (ссылка на следующий элемент связного списка).
Оптимален для вставки и удаления (т.к. надо просто "перекинуть" указатель с определенного элемента на следующий).
Плох для индексирования и поиска (сложно получить элемент по его номеру или просто найти элемент из-за вложенности).
Дополнительно:
Существует двусвязный список: он имеет помимо nextNode и value ещё и previousNode (значение узла, ссылка на следующий узел и на предыдущий соответственно).

3)Стек
Обычно реализуется с помощью связного списка, может быть создан и из массива
Стеки — это LIFO-структуры данных (last in, first out).
Аналог стека — стопка тарелок: последнюю добавленную в стопку тарелку возьмут первой.
Голова – единственное место для вставки и удаления элементов.

4)Очереди
Как и стек очереди могут быть реализованы с помощью связного списка или массива.
Очереди — это FIFO-структуры данных (first in, first out).
Аналог очереди - очередь в магазине: первого покупателя обслужат первым
Элементы удаляются из головы, а добавляются в хвост.

5)Хэш-таблица (объект)
Данные хранятся в виде пар ключ-значение.
Оптимальны для поиска, вставки и удаления.

6)Двоичное дерево
Двоичное дерево — структура данных, в которой каждый узел имеет максимум два дочерних элемента. Дочерние элементы бывают левым и правым. Ключ левого дочернего узла меньше, чем у родительского. Ключ правого дочернего узла больше, чем у родительского.
Оптимальны для сортировки и поиска.

Базовые алгоритмы сортировки и поиска.
1)Пузырьковая сортировка
Пробегает набор данных слева направо, сравнивая значения внутри каждой пары и перемещая наименьшее влево. Процесс повторяется до тех пор, пока ни одно значение уже не может быть перемещено.
Алгоритм очень прост в реализации, но малоэффективен

function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - 1 - i; j++) {
      if (arr[j + 1] < arr[j]) {
        let t = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = t;
      }
    }
  }
  return arr;
}
bubbleSort(arr);

2)Сортировка слиянием (merge sort)
Весь набор данных делится минимум на две группы. Пары значений сравниваются между собой, наименьшее перемещается влево. После сортировки внутри всех пар, сравниваются левые значения двух левых пар. Таким образом, создаётся группа из четырёх значений: два наименьшие — слева, наибольшие — справа. Процесс повторяется до тех пор, пока не останется только один набор.

3)Быстрая сортировка
Весь набор данных делится пополам путём выбора среднего элемента и перемещения всех, кто меньше него, влево. Затем такая же процедура итерационно выполняется с левой частью до тех пор, пока не останутся только два элемента. В результате левая часть окажется отсортированной. Затем всё то же самое делается с правой частью.
Хотя «О» большое здесь имеет те же значения (а в ряде случаев — хуже), что и у многих других алгоритмов сортировки, но на практике этот алгоритм зачастую работает быстрее, например, той же сортировки слиянием. Данные будут последовательно делиться пополам, пока не будут целиком отсортированы.

Сравнение алгоритмов сортировки слиянием и быстрой сортировки

Быстрая сортировка на практике зачастую эффективнее. Сортировка слиянием сразу делит набор данных на наименьшие возможные группы, а затем восстанавливает набор, инкрементально сортируя и укрупняя группы. Быстрая сортировка последовательно делит набор по среднему значению, пока он не будет отсортирован рекурсивно.

Быстрая сортировка

function quickSort(arr) {
  if (arr.length == 0) return [];
  let a = [],
    b = [],
    p = arr[0];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < p) a.push(arr[i]);
    else b.push(arr[i]);
  }
  return quickSort(a).concat(p, quickSort(b));
}
quickSort(arr);

4)Бинарный поиск

const arr = [1, 2, 4, 6, 1, 100, 0, 10000, 3];
function binarySearch(arr, i) {
  let mid = Math.floor(arr.length / 2);

  if (arr[mid] === i) {
    return arr[mid];
  } else if (arr[mid] < i && arr.length > 1) {
    return binarySearch(arr.splice(mid, Number.MAX_VALUE), i);
  } else if (arr[mid] > i && arr.length > 1) {
    return binarySearch(arr.splice(0, mid), i);
  } else {
    return -1;
  }
}
binarySearch(arr, 100);

Основы html/css:

Значения атрибута display
display: block | inline | inline-block | inline-table | list-item | none | run-in | table | table-caption | table-cell | table-column-group | table-column | table-footer-group | table-header-group | table-row | table-row-group

Вес селекторов (специфичность):
style=""1,0,0,0 #id0,1,0,0 .class0,0,1,0 [attr=value]0,0,1,0 LI0,0,0,1 *0,0,0,0

Псевдоклассы – это селекторы, которые определяют состояние уже существующих элементов, которое может меняться при определенных условиях.
Псевдоэлементы – это селекторы, которые определяют область элементов, которая изначально отсутствует в дереве документа. Эта область создается искусственно с помощью CSS.
Ключевое отличие между ними в том, что псевдоклассы определяют именно состояние элементов, которые уже существуют на странице, а псевдоэлементы создают области (искусственные элементы), которых изначально на веб-странице не было. Но и те и другие отсутствуют в исходном коде документа.

список псевдоклассов:
E:root E:nth-child(n) E:nth-last-child(n) E:nth-of-type(n) E:nth-last-of-type(n) E:first-child E:last-child E:first-of-type E:last-of-type E:only-child E:only-of-type E:empty E:link E:visited E:active E:hover E:focus E:target E:lang(fr) E:enabled E:disabled E:checked E:not(s)
Псевдоэлементы:
E::first-line E::first-letter E::before E::after

Box model
В HTML-документе каждому элементу на странице соответствует прямоугольная область (бокс или блок).В языке CSS есть специальная боксовая модель (также блоковая модель или блочная модель, англ. box model), которая описывает, из чего состоит бокс и какие свойства влияют на его размеры. В ней у каждого бокса есть 4 области: margin (внешние отступы), border (рамка), padding (внутренние поля), и content (контент или содержимое).

Единицы измерения: px, em, rem и другие:
px – абсолютные пиксели, к которым привязаны и потому не нужны mm, cm, pt и pc. Используется для максимально конкретного и точного задания размеров.
em – задаёт размер относительно шрифта родителя, можно относительно конкретных символов: "x"(ex) и "0"(ch), используется там, где нужно упростить масштабирование компоненты.
rem – задаёт размер относительно шрифта <html>, используется для удобства глобального масштабирования: элементы которые планируется масштабировать, задаются в rem, а JS меняет шрифт у <html>.
% – относительно такого же свойства родителя (как правило, но не всегда), используется для ширин, высот и так далее, без него никуда, но надо знать, относительно чего он считает проценты.
vw(1% ширины окна), vh(1% высоты окна), vmin, vmax – относительно размера экрана.

HTML (от англ. HyperText Markup Language — «язык гипертекстовой разметки») — стандартизированный язык гипертекстовой разметки документов для просмотра веб-страниц в браузере

Элемент <!DOCTYPE> предназначен для указания типа текущего документа — DTD (document type definition, описание типа документа). Это необходимо, чтобы браузер понимал, как следует интерпретировать текущую веб-страницу, поскольку HTML существует в нескольких версиях

Базовая структура любого HTML-документа:
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Моя первая страница</title>
</head>
<body>
</body>
</html>

Семантическая вёрстка — подход к разметке, который опирается не на содержание сайта, а на смысловое предназначение каждого блока и логическую структуру документа.
Список основных:
<article>
Значение: независимая, отделяемая смысловая единица, например комментарий, твит, статья, виджет ВК и так далее.
<section>
Значение: смысловой раздел документа. Неотделяемый, в отличие от <article>.
<aside>
Значение: побочный, косвенный для страницы контент.
<nav>
Значение: навигационный раздел со ссылками на другие страницы или другие части страниц.
<header>
Значение: вводная часть смыслового раздела или всего сайта, обычно содержит подсказки и навигацию. Чаще всего повторяется на всех страницах сайта.
<main>
Значение: основное, не повторяющееся на других страницах, содержание страницы.
<footer>
Значение: заключительная часть смыслового раздела или всего сайта, обычно содержит информацию об авторах, список литературы, копирайт и так далее. Чаще всего повторяется на всех страницах сайта.

Потоком документа в HTML называется порядок вывода элементов на страницу. В обычном виде все блоки выводятся в том порядке, в котором они записаны внутри HTML-документа.

Позиционирование позволяет вам изымать элементы из нормального потока макета документа и заставить их вести себя по-другому
Список:
static-лок располагается в соответствии с нормальным потоком. Свойства top, right, bottom и left не применяются. Значение по умолчанию.
relative-Положение блока рассчитывается в соответствии с нормальным потоком. Затем блок смещается относительно его нормального положения и во всех случаях, включая элементы таблицы, не влияет на положение любых следующих блоков.
Относительно позиционированный блок создает новый содержащий блок для абсолютно позиционированных потомков.
absolute-Абсолютно позиционированные блоки полностью удаляется из нормального потока, не влияя на расположение сестринских элементов.одержимое абсолютно позиционированного элемента не может обтекать другие блоки. Абсолютно позиционированный блок могут скрывать содержимое другого блока (или сами могут быть скрыты), в зависимости от значения z-index перекрывающихся блоков.
sticky-Положение блока рассчитывается в соответствии с нормальным потоком. Затем блок смещается относительно своего ближайшего предка с прокруткой или окна просмотра, если ни у одного из предков нет прокрутки.
fixed-Фиксированное позиционирование аналогично абсолютному позиционированию, с отличием в том, что для содержащим блоком устанавливается окно просмотра. Такой блок полностью удаляется из потока документа и не имеет позиции относительно какой-либо части документа. Фиксированные блоки не перемещаются при прокрутке документа. В этом отношении они похожи на фиксированные фоновые изображения. 

Свойство CSS overflow определяет, необходимо ли для переполненного блочного элемента содержимое обрезать, предоставить полосы прокрутки или просто отобразить.Значения visible,hidden,scroll,auto

Разница между блочными и строчными элементами следующая.
Строчные элементы могут содержать только данные или другие строчные элементы, а в блочные допустимо вкладывать другие блочные элементы, строчные элементы, а также данные. Иными словами, строчные элементы никак не могут хранить блочные элементы.
Блочные элементы всегда начинаются с новой строки, а строчные таким способом не акцентируются.
Блочные элементы занимают всю доступную ширину, например, окна браузера, а ширина строчных элементов равна их содержимому плюс значения отступов, полей и границ.

В чём разница между отзывчивым и адаптивным веб-дизайном. Основное отличие между этими приёмами — отзывчивый дизайн — один макет для всех устройств, адаптивный дизайн — один макет для каждого вида устройства.

JS


Стандарт ECMAScript определяет 8 типов:
6 типов данных являющихся примитивами:
Undefined (Неопределённый тип)  : typeof instance === "undefined"
Boolean (Булев, Логический тип) : typeof instance === "boolean"
Number (Число) : typeof instance === "number"
String (Строка) : typeof instance === "string"
BigInt  : typeof instance === "bigint"
Symbol (в ECMAScript 6)  : typeof instance === "symbol"
Null (Null тип ) : typeof instance === "object". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;
Object (Объект) : typeof instance === "object". Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, new Date и множество других структур;

Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.

Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.
Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.
Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).
Преобразование подчиняется правилам:
Значение	Становится…
undefined	NaN
null	          0
true / false	1 / 0
string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).
Подчиняется правилам:
Значение	Становится…
0, null, undefined, NaN, ""	false
любое другое значение	        true

Термины: «унарный», «бинарный», «операнд»
Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».
Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный
Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:

Иногда вам захочется повторно добавить или вычесть единцу к/из значению числовой переменной. Это можно сделать с помощью оператора инкремента (++) и декремента (--).

Операторы предназначенные для организации циклов в  JavaScript:

Цикл_for
Цикл_do...while
Цикл_while
Метка_(label)
break
continue
for...in
for...of
Оба оператора, и for...in и for...of производят обход объектов . Разница в том, как они это делают.
Для for...in обход перечисляемых свойств объекта осуществляется в произвольном порядке.
Для for...of обход происходит в соответствии с тем, какой порядок определён в итерируемом объекте.
for..of подходит для обхода объекта number / array / string / map / set и других коллекций с объектами-итераторами. Но он не может перемещаться по объекту, потому что нет объекта-итератора. В отличие от forEach (), он может правильно реагировать на break, операторы continue и return
Цикл for-of не поддерживает обычные объекты, но если вы хотите перебрать свойства объекта, вы можете использовать цикл for-in (который также является его заданием) или встроенный метод Object.keys ()
Цикл for...in проходит только по перечисляемым свойствам. Объекты, созданные встроенными конструкторами, такими как Array и Object имеют неперечисляемые свойства от Object.prototype и String.prototype, например, от String-это indexOf(), а от Object - метод toString(). Цикл пройдёт по всем перечисляемым свойствам объекта, а также тем, что он унаследует от конструктора прототипа (свойства объекта в цепи прототипа).